import * as vscode from 'vscode';
import { CodeContextInfo } from './CodeContextInfo';
import { commentKeyWords, CommentkeyWords, CommentType, triggerSequence, arroba, arrobaTab, endLine } from './Commons';

function generateFileDescription(fileName: string) : string {
	const defaultFileComment: string =
		triggerSequence +
		arroba + commentKeyWords[CommentkeyWords.FILE] + fileName +
		arroba + commentKeyWords[CommentkeyWords.AUTHOR] + "John Doe" +
		arroba + commentKeyWords[CommentkeyWords.BRIEF] + "This file contains this thing." +
		endLine;
	return defaultFileComment;
}

function generateComplexDescription() : string {
	const defaultComplexComment: string =
		triggerSequence +
		arroba + commentKeyWords[CommentkeyWords.STRUCT] + "structName" +
		arroba + commentKeyWords[CommentkeyWords.BRIEF] + "this struct represent this thing." +
		arroba + commentKeyWords[CommentkeyWords.FIELD] + "fieldName:" +
		arrobaTab + commentKeyWords[CommentkeyWords.TYPE] + "char pointer" +
		arrobaTab + commentKeyWords[CommentkeyWords.BRIEF] + "this field describe this thing." +
		endLine;
	return defaultComplexComment;
}

function generateMethodDeription() : string {
	const defaultMethodComment: string =
		triggerSequence +
		arroba + commentKeyWords[CommentkeyWords.FUNC] + "funcName" +
		arroba + commentKeyWords[CommentkeyWords.BRIEF] + "this function does this thing." +
		arroba + commentKeyWords[CommentkeyWords.PARAM] + "paramName:" +
		arrobaTab + commentKeyWords[CommentkeyWords.TYPE] + "char pointer" +
		arrobaTab + commentKeyWords[CommentkeyWords.BRIEF] + "this param describe this thing." +
		endLine;
	return defaultMethodComment;
}

function generateVariableDeription() : string {
	const defaultVariableComment: string =
		triggerSequence +
		arroba + commentKeyWords[CommentkeyWords.VARIABLE] + "varName" + 
		arrobaTab + commentKeyWords[CommentkeyWords.TYPE] + "char pointer" +
		arrobaTab + commentKeyWords[CommentkeyWords.BRIEF] + "this variable describe this thing." +
		endLine;
	return defaultVariableComment;
}

function generateDefDeription() : string {
	const defaultVariableComment: string =
		triggerSequence +
		arroba + commentKeyWords[CommentkeyWords.DEF] + "define name" + 
		arrobaTab + commentKeyWords[CommentkeyWords.BRIEF] + "this define does this thing." +
		arrobaTab + commentKeyWords[CommentkeyWords.PARAM] + "(optional)" +
		endLine;
	return defaultVariableComment;
}

function generateEnumDeription() : string {
	const defaultVariableComment: string =
		triggerSequence +
		arroba + commentKeyWords[CommentkeyWords.ENUM] + "Enum name" + 
		arrobaTab + commentKeyWords[CommentkeyWords.BRIEF] + "this enum represent this thing." +
		arrobaTab + commentKeyWords[CommentkeyWords.TAG] + "(optional)" +
		endLine;
	return defaultVariableComment;
}

function moveCursor(activeEditor: vscode.TextEditor, comment: string, baseLine: number, baseCharacter: number) {
	// Find first offset of a new line in the comment. Since that's when the line where the first param starts.
	let line: number = baseLine;
	let character: number = comment.indexOf("\n");

	// If a first line is included find the 2nd line with a newline.
	if (triggerSequence.length !== 0) {
		line++;
		const oldCharacter: number = character;
		character = comment.indexOf("\n", oldCharacter + 1) - oldCharacter;
	}

	// If newline is not found means no first param was found so Set to base line before the newline.
	if (character < 0) {
		line = baseLine;
		character = baseCharacter;
	}
	const to: vscode.Position = new vscode.Position(line, character);
	activeEditor.selection = new vscode.Selection(to, to);
}

export function GenerateDoc(activeEditor: vscode.TextEditor, contextInfo: CodeContextInfo, rangeToReplace: vscode.Range) {
	let comment: string = "";
	switch (contextInfo.commentType) {
	case CommentType.FILE:
		comment = generateFileDescription(activeEditor.document.fileName);
		break;
	case CommentType.COMPLEX:
		comment = generateComplexDescription();
		break;
	case CommentType.METHOD:
		comment = generateMethodDeription();
		break;
	case CommentType.VARIABLE:
		comment = generateVariableDeription();
		break;
	case CommentType.DEF:
		comment = generateDefDeription();
		break;
	case CommentType.ENUM:
		comment = generateEnumDeription();
		break;
	default:
		console.log("CommentType not supported.");
		return;
	}

	// overwrite any autogenerated comment closer
	let modifiedRangeToReplace = rangeToReplace;
	if (contextInfo.vsAutoGenComment) {
		const newPos: vscode.Position = new vscode.Position(
			modifiedRangeToReplace.end.line + 1,
			modifiedRangeToReplace.end.character,
		);
		modifiedRangeToReplace = new vscode.Range(rangeToReplace.start, newPos);
	}

	activeEditor.edit((editBuilder) => {
		editBuilder.replace(modifiedRangeToReplace, comment); // Insert the comment
	});

	// Set cursor to first DoxyGen command.
	moveCursor(activeEditor, comment,
		modifiedRangeToReplace.start.line,
		modifiedRangeToReplace.start.character);
}

function isVsCodeAutoComplete(line: string): boolean {
	switch (line) {
		case "*/":
			return true;
		default:
			return false;
	}
}

// Get the next line with valid logic (no comments or empty)
function GetLogicLine(activeEditor: vscode.TextEditor): [string, CommentType] {
	let logicalLine: string = "";
	
	// take the next line since comments are always above the line to document
	let nextLine: vscode.Position = new vscode.Position(activeEditor.selection.active.line + 1,
														activeEditor.selection.active.character);
	let nextLineTxt: string = activeEditor.document.lineAt(nextLine.line).text.trim();

	// VSCode may enter a * on itself, we don't want that in our method
	if (nextLineTxt === "*") {
		nextLineTxt = "";
	}

	let currentNest: number = 0;

	// Get method end line
	let linesToGet: number = 20;
	while (linesToGet-- > 0) { // Check for end of expression.
		nextLine = new vscode.Position(nextLine.line + 1, nextLine.character);
		nextLineTxt = activeEditor.document.lineAt(nextLine.line).text.trim();
		let finalSlice = -1;

		// Check if method has finished if curly brace is opened while
		// nesting is occuring.
		for (let i: number = 0; i < nextLineTxt.length; i++) {
			if (nextLineTxt[i] === "(") {
				currentNest++;
			} else if (nextLineTxt[i] === ")") {
				currentNest--;
			} else if (nextLineTxt[i] === "{" && currentNest === 0) {
				finalSlice = i;
				break;
			} else if (
				(nextLineTxt[i] === ";" || (nextLineTxt[i] === ":" && nextLineTxt[i - 1] !== ":" && nextLineTxt[i + 1] !== ":"))
				&& currentNest === 0) {
				finalSlice = i;
				break;
			}
		}

		// Head of file probably
		if (nextLineTxt.startsWith("#include")) {
			return [nextLineTxt, CommentType.FILE];
		} else if (nextLineTxt.startsWith("#define")) {
			return [nextLineTxt, CommentType.DEF];
		 } else if (nextLineTxt.startsWith("typedef struct") || nextLineTxt.startsWith("struct") ||
					nextLineTxt.startsWith("typedef union") || nextLineTxt.startsWith("union")) {
			return [nextLineTxt, CommentType.COMPLEX];
		} else if (nextLineTxt.startsWith("typedef enum") || nextLineTxt.startsWith("enum")) {
			return [nextLineTxt, CommentType.ENUM];
		}

		if (!isVsCodeAutoComplete(nextLineTxt)) {
			logicalLine += "\n";
			if (finalSlice >= 0) {
				logicalLine += nextLineTxt.slice(0, finalSlice);
			} else {
				logicalLine += nextLineTxt;
			}
			logicalLine.replace(/\*\//g, "");
		}

		if (finalSlice >= 0) {
			return [logicalLine.replace(/^\s+|\s+$/g, ""), CommentType.METHOD];
		}
	}

	return ["", CommentType.UNKNOWN];
}

export function parse(activeEditor: vscode.TextEditor) : CodeContextInfo {
	let vsAutoGenComment: boolean = false;
	let commentType: CommentType = CommentType.METHOD;
	let line: string = "";

	// head of file
	if (activeEditor.selection.active.line === 0 && line.length === 0) {
		commentType = CommentType.FILE;
	}
	// Struct|Complex / var / method
	else {
		[line, commentType] = GetLogicLine(activeEditor);
		switch (commentType) {
		case CommentType.ENUM:
		case CommentType.COMPLEX:
			//let args: [CArg, CArg[]] = [new CArg(), []];
			//args = GetReturnAndArgs(line);
			break;
		case CommentType.VARIABLE:
		case CommentType.METHOD:
			break;
		case CommentType.FILE:
		case CommentType.DEF:
		default:
			break;
		}
	}
	
	vsAutoGenComment = isVsCodeAutoComplete("*/\n");
	let contextInfo = new CodeContextInfo(commentType, vsAutoGenComment);
	return contextInfo;
}
